<dom-module id="sm-canvas">
  <template>
    <style>
       :host {
        display: block;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        background: #f0f0f0;
        display: block;
      }
    </style>
    <canvas id="canvas" width="0" height="0"></canvas>
  </template>

  <script>
    'use strict';
    const BACKGROUND_COLOR = 'white';
    const GRID_COLOR = 'lightgray';
    const LS_GRID_KEY = 'sm_grid';

    const toRelativeUnit = (n, ratio) => Math.floor(n / ratio),
          toPixel = (n, ratio) => n * ratio;


    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      toRelativeUnit(ratio) {
        return {
          x: Math.floor(this.x / ratio),
          y: Math.floor(this.y / ratio)
        };
      }

      add(p) {
        this.x = this.x + p.x;
        this.y = this.y + p.y;
      }
    }

    class Stitch {
      constructor(x, y, stitch, grid) {
        this.x = x;
        this.y = y;
        this._grid = grid;

        Object.assign(this, stitch);
        // this.stitch = stitch;
      }

      draw(ctx) {
        let size = this._grid.stitchSize,
          x = toPixel(this.x, size) + 1,
          y = toPixel(this.y, size) + 1,
          innerSize = size - 1,
          half = innerSize / 2;

        const symbolWidth = ctx.measureText(this.symbol).width;

        // draw background
        ctx.fillStyle = this.color;
        ctx.fillRect(x, y, innerSize, innerSize);

        // draw symbol
        ctx.fillStyle = 'black';
        ctx.font = innerSize * .9 + "px Arial";

        ctx.fillText(this.symbol, x + (innerSize - symbolWidth) / 2, y + innerSize * .9);
      }

      toJSON() {
        let result = {};
        const tempAttrs = ['_grid'];

        for (let x in this) {
          if (~tempAttrs.indexOf(x)) continue;

          result[x] = this[x];
        }
        return result;
      }
    }

    class Canvas extends Polymer.Element {
      static get is() { return 'sm-canvas'; }

      static get properties() {
        return {
          enabled: {
            type: Object,
            reflectToAttribute: true
          },

          zoom: {
            type: Number,
            reflectToAttribute: true
          }
        };
      }

      static get observers() {
        return [
          '_enabledChanged(enabled)',
          '_zoomChanged(zoom)'
        ]
      }

      constructor() {
        super();
        this.canvas = this.$.canvas;
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;


        let timer;
        window.addEventListener('resize', (e) => {
          // TODO: Discuss why this implementation is better than what was before. In my understanding canvas should fit into container it is rendered in.

          clearTimeout(timer);
          timer = setTimeout(() => {
            this._resize(window.innerWidth, window.innerHeight);
          }, 250);
        });
      }

      reset() {
        this.cells = new Array(this.wCells * this.hCells);
        this._draw();
      }

      save() {
        toLocalStorage(LS_GRID_KEY, this);
      }


      toJSON() {
        let result = {};
        result.cells = this.cells.filter(c => c);
        console.log(result.cells);
        return result;
      }

      _enabledChanged() {
        if (this.enabled) {
          console.log('Rendering.');
          this._init();
          this._draw();
        }
      }

      _zoomChanged(zoom) {
        if (this.enabled) {
          this._zoom({
            x: this.canvas.width / 2,
            y: this.canvas.height / 2
          }, zoom);
        }
      }

      _init() {
        this.zoom = this.zoom || 4;
        this.stitchSize = Math.round(this.zoom * 5);
        this.wCells = this.config ? this.config.ratio[0] : 50;
        this.hCells = this.config ? this.config.ratio[1] : 50;
        this.cells = new Array(this.wCells * this.hCells);
        this.zp = new Point(0, 0);   // relative zero point - begin of ctx
        this.mode = 'move';
        this.events = {
          mouseup: (e) => this._handleMouseUp(e),
          mousedown: (e) => this._handleMouseDown(e),
          mousemove: (e) => this._handleMouseMove(e),
          // touchstart : (e) => this._handleTouchStart(e),
          // touchend   : (e) => this.handleTouchEnd(e),
          // touchmove  : (e) => this.handleTouchMove(e),
          mousewheel: (e) => this._handleWheel(e),
          // wheel      : (e) => this._handleTouchStart(e),
          // scroll     : (e) => this._handleTouchStart(e),
        }
        const storedGrid = fromLocalStorage(LS_GRID_KEY);

        if (storedGrid) {
          console.log(storedGrid);
          storedGrid.cells.forEach(c => {
            this.cells[c.x + this.wCells * c.y] = new Stitch(c.x, c.y, {color: c.color, symbol: c.symbol}, this);
          });
        }

        // setup events
        for (let e in this.events) {
          this.canvas.addEventListener(e, this.events[e]);
        }
      }

      _draw() {
        this._drawGrid();
      }

      _drawGrid() {
        let size = this.stitchSize,
          gridWidth = toPixel(this.wCells, size),
          gridHeight = toPixel(this.hCells, size),
          zp = this.zp,
          ctx = this.ctx,
          // draw grid only in window
          begin = new Point(
            Math.max(0, zp.x % size - zp.x - size),
            Math.max(0, zp.y % size - zp.y - size)
          ),
          end = new Point(
            Math.min(this.canvas.width - zp.x, gridWidth),
            Math.min(this.canvas.height - zp.y, gridHeight)
          ),
          _begin = begin.toRelativeUnit(size),
          _end = end.toRelativeUnit(size);

        // background of grid
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, gridWidth, gridHeight);

        // color of grid
        ctx.strokeStyle = GRID_COLOR;
        ctx.lineWidth = 1;
        ctx.beginPath();

        let x, y;
        for (let x = begin.x + 0.5; x <= end.x + 1; x += size) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, end.y);
        }

        for (let y = begin.y + 0.5; y <= end.y + 1; y += size) {
          ctx.moveTo(0, y);
          ctx.lineTo(end.x, y);
        }
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let x = begin.x; x <= end.x + 1; x += size) {
          if (!(x % (10 * size))) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, end.y);
          }
        }

        for (let y = begin.y; y <= end.y + 1; y += size) {
          if (!(y % (10 * size))) {
            ctx.moveTo(0, y);
            ctx.lineTo(end.x, y);
          }
        }
        ctx.stroke();

        for (let x = _begin.x, cell; x <= _end.x; x++) {
          for (let y = _begin.y; y <= _end.y; y++) {
            cell = this.cells[x + this.wCells * y];

            if (cell) cell.draw(this.ctx);
          }
        }
      }

      _moveTo(x, y) {
        this.zp.x += x;
        this.zp.y += y;
        this.ctx.translate(x, y);
        this._redraw();
      }

      _zoom(focus, zoom) {
        let oldSize = this.stitchSize;

        this.zoom = +zoom.toFixed(2);
        this.stitchSize = Math.round(this.zoom * 5);

        if (this.zoom >= 1) {
          let k = 1 - this.stitchSize / oldSize;

          this._moveTo(
            Math.round((focus.x - this.zp.x) * k),
            Math.round((focus.y - this.zp.y) * k)
          );
        }
      }

      _clearGrid() {
        let begin = new Point(0 - this.zp.x, 0 - this.zp.y),
          end = new Point(this.canvas.width, this.canvas.height);

        this.ctx.clearRect(begin.x, begin.y, end.x, end.y);
      }

      _redraw() {
        this._clearGrid();
        this._draw();
      }

      _resize(width, height) {
        this.ctx.translate(-this.zp.x, -this.zp.y);
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.translate(this.zp.x, this.zp.y);

        this._redraw();
      }

      _setCell(pt, color) {
        let i = pt.x + this.wCells * pt.y;
        if (this.shape === 'eraser') {
          delete this.cells[i];
          this._redraw();
        } else if (!this.cells[i] && this.shape !== 'eraser') {
          this.cells[i] = new Stitch(pt.x, pt.y, this.stitch, this);
          this.cells[i].draw(this.ctx);
        }
      }

      _isInGrid(pt) {
        return pt.x >= 0 &&
          pt.x < this.wCells &&
          pt.y >= 0 &&
          pt.y < this.hCells;
      }

      // events handlers

      _handleMouseUp(e) {
        e.preventDefault();
        // if (this.mode === 'draw') {
        //   let pt = new Point(
        //     e.clientX - this.zp.x,
        //     e.clientY - this.zp.y
        //   ).toRelativeUnit(this.stitchSize);

        //   if (this.inGrid(pt)) {
        //       this.setCell(pt, $colorpicker && $colorpicker.value || 'black');
        //   }
        // }
        let pt = new Point(
          e.clientX - this.zp.x,
          e.clientY - this.zp.y
        ).toRelativeUnit(this.stitchSize);

        if (this._isInGrid(pt)) {
          this._setCell(pt, this.color);
        }

        this.moveStart = null;
      }

      _handleMouseDown(e) {
        e.preventDefault();
        this.moveStart = { x: e.clientX, y: e.clientY };

        let moveEnd = { x: e.clientX, y: e.clientY },
          move = () => {
            if (this.moveStart) {
              let deltaX = this.moveStart.x - moveEnd.x,
                deltaY = this.moveStart.y - moveEnd.y;

              if (deltaX || deltaY) this._moveTo(deltaX, deltaY);

              moveEnd = { x: this.moveStart.x, y: this.moveStart.y };
              requestAnimationFrame(move);
            }
          }
        move();
      }

      _handleMouseMove(e) {
        e.preventDefault();
        if (e.which === 1 && this.moveStart) {
          let pt = new Point(
            e.clientX - this.zp.x,
            e.clientY - this.zp.y
          ).toRelativeUnit(this.stitchSize);

          if (this._isInGrid(pt)) {
            this._setCell(pt, this.color);
            // } else if (this.mode === 'move') {
            //   this.moveStart = { x: e.clientX, y: e.clientY };
          }
        } else {
          this.moveStart = null;
        }
      }
      _handleWheel(e) {
        e.preventDefault();

        this._moveTo(-e.deltaX, -e.deltaY);
        // this.moveStart = { x: e.clientX, y: e.clientY };
      }
      _handleTouchMove(e) { }
      _handleTouchEnd(e) {
        this.moveStart = null;
      }
    }

    customElements.define(Canvas.is, Canvas);
  </script>
</dom-module>