<dom-module id="sm-canvas">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        background: #f0f0f0;
        display: block;
      }
    </style>
    <canvas id="canvas" width="0" height="0"></canvas>
  </template>

  <script>
    'use strict';
    var toRelativeUnit = (n, ratio) => Math.floor(n / ratio);
    var toPixel = (n, ratio) => n * ratio;

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      toRelativeUnit(ratio) {
        return {
          x: Math.floor(this.x / ratio),
          y: Math.floor(this.y / ratio)
        };
      }
      add(p) {
        this.x = this.x + p.x;
        this.y = this.y + p.y;
      }
    }

    class Canvas extends Polymer.Element {
      static get is() { return 'sm-canvas'; }

      static get config() {
        return {
          properties: {
            // enabled: {
            //   type: Object,
            //   reflectToAttribute: true,
            //   // observer: '_enabledChanged'
            // }

          },
          observers: [
            '_enabledChanged(enabled)',
            '_configChangedScale(scale)'
          ]
        };
      }

      constructor() {
        super();

      }

      _enabledChanged() {
        if (this.enabled) {
          console.log('Rendering.');
          this._init();
          this._draw();
        }
      }
      _configChangedScale(newVal) {
        if (this.enabled) {
          this._updateScale(newVal);
        // console.log(config);
        }
        // console.log('Canvas config changed.');
      }
      _updateScale(scale) {
        // this.scale  = scale;
        // this.cellSize = Math.round(this.scale * 5);
        this._zoom({
          x: this.canvas.width / 2,
          y: this.canvas.height / 2
        }, scale);
      }
      _init() {
        this._offsetX = 10;
        this._offsetY = 10;
        this.canvas   = this.$.canvas;
        this.ctx      = this.canvas.getContext('2d');
        this.scale    = this.scale || 3;
        this.scaleOpt = {};
        this.cellSize = Math.round(this.scale * 5);
        this.wCells   = this.config ? this.config.ratio[0] : 50;
        this.hCells   = this.config ? this.config.ratio[1] : 50;
        this.zp       = new Point(0, 0);   // relative zero point - begin of ctx
        this.mode     = 'move';
        this.cells    = new Array(this.wCells * this.hCells);
        this.events   = {
          mouseup    : (e) => this._handleMouseUp(e),
          mousedown  : (e) => this._handleMouseDown(e),
          mousemove  : (e) => this._handleMouseMove(e),
          // touchstart : (e) => this._handleTouchStart(e),
          // touchend   : (e) => this.handleTouchEnd(e),
          // touchmove  : (e) => this.handleTouchMove(e),
          mousewheel : (e) => this._handleWheel(e),
          // wheel      : (e) => this._handleTouchStart(e),
          // scroll     : (e) => this._handleTouchStart(e),
        }



        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;


        // setup events
        for (let e in this.events) {
          this.canvas.addEventListener(e, this.events[e]);
        }

        let timer;
        window.addEventListener('resize', (e) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
              this._resize(window.innerWidth, window.innerHeight);
          }, 250);
        });
      }

      _draw() {
        this._drawGrid();
      }

      _drawGrid() {
        let size       = this.cellSize,
            gridWidth  = toPixel(this.wCells, size),
            gridHeight = toPixel(this.hCells, size),
            zp         = this.zp,
            ctx        = this.ctx,
            // draw grid only in window
            begin      = new Point(
                          Math.max(0, zp.x % size - zp.x - size),
                          Math.max(0, zp.y % size - zp.y - size)
                        ),
            end        = new Point(
                          Math.min(this.canvas.width - zp.x, gridWidth),
                          Math.min(this.canvas.height - zp.y, gridHeight)
                        ),
            _begin     = begin.toRelativeUnit(size),
            _end       = end.toRelativeUnit(size);

        // background of grid
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, gridWidth, gridHeight);

        // color of grid
        ctx.strokeStyle = 'lightgray';
        ctx.lineWidth = 1;
        ctx.beginPath();

        let x, y;
        for (let x = begin.x + 0.5; x <= end.x + 1; x += size) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, end.y);
        }

        for (let y = begin.y + 0.5; y <= end.y + 1; y += size) {
          ctx.moveTo(0, y);
          ctx.lineTo(end.x, y);
        }
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let x = begin.x; x <= end.x + 1; x += size) {
          if (!(x % (10 * size))) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, end.y);
          }
        }

        for (let y = begin.y; y <= end.y + 1; y += size) {
          if (!(y % (10 * size))) {
            ctx.moveTo(0, y);
            ctx.lineTo(end.x, y);
          }
        }
        ctx.stroke();

        for (let x = _begin.x, cell; x <= _end.x; x++) {
          for (let y = _begin.y; y <= _end.y; y++) {
            cell = this.cells[x + this.wCells * y];

            if (cell) cell.draw();
          }
        }
      }

      _moveTo(x, y) {
        this.zp.x += x;
        this.zp.y += y;
        this.ctx.translate(x, y);
        this._redraw();
      }

      _zoom(focus, scale) {
        let oldSize   = this.cellSize;

        this.scale    = +scale.toFixed(2);
        this.cellSize = Math.round(this.scale * 5);

        if (this.scale >= 1) {
          let k = 1 - this.cellSize / oldSize;

          this._moveTo(
            Math.round((focus.x - this.zp.x) * k),
            Math.round((focus.y - this.zp.y) * k)
          );
        }
      }

      _clearGrid() {
        let begin = new Point(0 - this.zp.x, 0 - this.zp.y),
            end   = new Point(this.canvas.width, this.canvas.height);

        this.ctx.clearRect(begin.x, begin.y, end.x, end.y);
      }

      _redraw() {
        this._clearGrid();
        this._draw();
      }

      _resize(width, height) {
        this.ctx.translate(-this.zp.x, -this.zp.y);
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.translate(this.zp.x, this.zp.y);

        this._redraw();
      }

      // events handlers

      _handleMouseUp(e) {
        e.preventDefault();
        // if (this.mode === 'draw') {
        //   let pt = new Point(
        //     e.clientX - this.zp.x,
        //     e.clientY - this.zp.y
        //   ).toRelativeUnit(this.cellSize);

        //   if (this.inGrid(pt)) {
        //       this.setCell(pt, $colorpicker && $colorpicker.value || 'black');
        //   }
        // }
        this.moveStart = null;
      }

      _handleMouseDown(e) {
        e.preventDefault();
        this.moveStart = { x: e.clientX, y: e.clientY };

        let moveEnd = { x: e.clientX, y: e.clientY },
            move    = () => {
              if (this.moveStart) {
                let deltaX = this.moveStart.x - moveEnd.x,
                    deltaY = this.moveStart.y - moveEnd.y;

                if ( deltaX || deltaY ) this._moveTo( deltaX, deltaY );

                moveEnd = { x: this.moveStart.x, y: this.moveStart.y };
                requestAnimationFrame(move);
              }
            }
        move();
      }

      _handleMouseMove(e) {
        e.preventDefault();
        if (e.which === 1 && this.moveStart) {
          let pt = new Point(
            e.clientX - this.zp.x,
            e.clientY - this.zp.y
          ).toRelativeUnit(this.cellSize);

          if (this.mode === 'draw' && this.inGrid(pt)) {
            this.setCell(pt, $colorpicker && $colorpicker.value || 'black');
          } else if (this.mode === 'move') {
            this.moveStart = { x: e.clientX, y: e.clientY };
          }
        } else {
          this.moveStart = null;
        }
      }
      _handleWheel(e) {
        e.preventDefault();

        this._moveTo( -e.deltaX, -e.deltaY );
        // this.moveStart = { x: e.clientX, y: e.clientY };
      }
      _handleTouchMove(e) {}
      _handleTouchEnd(e) {
        this.moveStart = null;
      }
    }

    customElements.define(Canvas.is, Canvas);
  </script>
</dom-module>