<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="stitch-canvas-new">
  <template>
    <style>
      :host {
        position: absolute;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
    </style>
    <canvas id="canvas"></canvas>
  </template>
  <script src="../helpers/round-rect.js"></script>
  <script src="./point.js"></script>
  <script src="./stitch.js"></script>
  <script src="./grid.js"></script>
  <script>
    class CanvasNew extends Polymer.Element {
      static get is() { return 'stitch-canvas-new'; }

      connectedCallback() {
        super.connectedCallback();

        const render = () => {
          this.$.canvas.width = this.offsetWidth;
          this.$.canvas.height = this.offsetHeight;

          const ctx = this.$.canvas.getContext('2d');

          let composite = new Composite(ctx);
          composite.draw();

          let move = null;

          ["mousedown", "touchstart"].forEach(type => {
            this.$.canvas.addEventListener(type, event => {
              move = getPoint(event);
            });
          });

          ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach(type => {
            this.$.canvas.addEventListener(type, event => {
              move = null;
            });
          });

          let reuestId = 0;

          ["mousemove", "touchmove"].forEach(type => {
            this.$.canvas.addEventListener(type, event => {
              if (move) {
                const newMove = getPoint(event);
                const dx = newMove.x - move.x;
                const dy = newMove.y - move.y;
                move = newMove;

                if (reuestId) cancelAnimationFrame(reuestId);
                reuestId = reuestId = requestAnimationFrame(() => composite.translate(dx, dy));

                event.preventDefault();
              }
            });
          });

          const getPoint = event => {
            const e = (event.touches && event.touches[0] || event);
            return new Point(e.clientX, e.clientY);
          }

        }

        if (this.offsetWidth) render();
        else requestAnimationFrame(render);
      }
    }

    class Tile {
      static get size() { return 256; }

      constructor(color) {
        this.color = color;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(0, 0, Tile.size, Tile.size);
      }
    }

    class Composite {
      constructor(ctx) {
        this.ctx = ctx;
        this.tiles = [];
        this.x = 0;
        this.y = 0;

        for (let row = 0; row < 25; row++) {
          for (var column = 0; column < 25; column++) {
            this.tiles[row * 25 + column] = new Tile(`rgb(${Math.floor(Math.random() * 255) + 1}, ${Math.floor(Math.random() * 255) + 1}, ${Math.floor(Math.random() * 255) + 1})`);
          }
        }
      }

      translate(x, y) {
        this.x += x;
        this.y += y;
        this.draw();
      }

      draw() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);

        let currentRow = Math.abs(Math.ceil(this.y / Tile.size));
        let column1 = Math.abs(Math.ceil(this.x / Tile.size));
        const columnCount = column1 + Math.abs(Math.ceil(this.x / Tile.size)) + Math.ceil(this.ctx.canvas.width / Tile.size) + 2;
        const rowCount = currentRow + Math.ceil(this.ctx.canvas.height / Tile.size) + 2;

        for (; currentRow < rowCount; currentRow++) {
          for (let column = column1; column < columnCount; column++) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.translate(this.x + column * Tile.size, this.y + currentRow * Tile.size);

            let tile = this.tiles[currentRow * 25 + column];
            tile.draw(this.ctx);
          }
        }
      }
    }

    customElements.define("stitch-canvas-new", CanvasNew);
  </script>
</dom-module>
