<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="stitch-canvas-new">
  <template>
    <style>
      :host {
        position: absolute;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
    </style>
    <canvas id="canvas"></canvas>
  </template>
  <script src="../helpers/round-rect.js"></script>
  <script src="./point.js"></script>
  <script src="./stitch.js"></script>
  <script src="./grid.js"></script>
  <script>
    class CanvasNew extends Polymer.Element {
      static get is() { return 'stitch-canvas-new'; }

      connectedCallback() {
        super.connectedCallback();

        const render = () => {
          this.$.canvas.width = this.offsetWidth;
          this.$.canvas.height = this.offsetHeight;

          const ctx = this.$.canvas.getContext('2d');

          let composite = new Composite(ctx, 8, 4);
          composite.draw();

          let move = null;

          ["mousedown", "mouseenter", "touchstart"].forEach(type => {
            this.$.canvas.addEventListener(type, event => {
              if ((event.type === "mouseenter" && event.buttons & 1 === 1) || event.type !== "mouseenter") {
                move = getPoint(event);
              }
            });
          });

          ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach(type => {
            this.$.canvas.addEventListener(type, event => {
              move = null;
            });
          });

          let reuestId = 0;

          ["mousemove", "touchmove"].forEach(type => {
            this.$.canvas.addEventListener(type, event => {
              if (move) {
                const newMove = getPoint(event);
                const dx = newMove.x - move.x;
                const dy = newMove.y - move.y;
                move = newMove;

                if (reuestId) cancelAnimationFrame(reuestId);
                reuestId = reuestId = requestAnimationFrame(() => composite.translate(dx, dy));

                event.preventDefault();
              }
            });
          });

          const getPoint = event => {
            const e = (event.touches && event.touches[0] || event);
            return new Point(e.clientX, e.clientY);
          }

        }

        if (this.offsetWidth) render();
        else requestAnimationFrame(render);
      }
    }

    class Tile {
      static get size() { return 256; }

      constructor(color) {
        this.color = color;
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(0, 0, Tile.size, Tile.size);
      }
    }

    class Composite {
      constructor(ctx, width, hight) {
        this.ctx = ctx;
        this.tiles = [];
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.hight = hight;

        for (let row = 0; row < this.hight; row++) {
          for (var column = 0; column < this.width; column++) {
            this.tiles[row * this.hight + column] = new Tile(`rgb(${Math.floor(Math.random() * 255) + 1}, ${Math.floor(Math.random() * 255) + 1}, ${Math.floor(Math.random() * 255) + 1})`);
          }
        }
      }

      translate(x, y) {
        this.x += x;
        this.y += y;
        this.draw();
      }

      draw() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);

        let horizontal = this.getRegion(this.y, this.hight, this.ctx.canvas.height);
        let vartical = this.getRegion(this.x, this.width, this.ctx.canvas.width);

        let rendered = 0;
        for (let row = horizontal.start; row < horizontal.end; row++) {
          for (let column = vartical.start; column < vartical.end; column++) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.translate(this.x + column * Tile.size, this.y + row * Tile.size);
            let tile = this.tiles[row * this.hight + column];
            tile && tile.draw(this.ctx);
            tile && rendered++;
          }
        }

        console.log(`rendered: ${rendered}`);
      }

      getRegion(coordinate, size, canvasSize){
        let current = Math.floor(Math.abs(Math.min(coordinate, 0)) / Tile.size);
        let fittingCount = Math.ceil((canvasSize - Math.max(coordinate, 0)) / Tile.size);
        let count = Math.min(current + fittingCount, size);
        if (count < size) count++;
        return {
          start: current,
          end: count
        };
      }
    }

    customElements.define("stitch-canvas-new", CanvasNew);
  </script>
</dom-module>
