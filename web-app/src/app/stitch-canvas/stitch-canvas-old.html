<dom-module id="stitch-canvas">
  <template>
    <style>
       :host {
        display: block;
        width: 100%;
        height: 700px;
        overflow: hidden;
      }
      #container {
        overflow: auto;
        height: 100%;
      }
      canvas {
        display: inline-block;
        box-sizing: content-box;
      }
    </style>
    <div id="container">
      <canvas id="canvas" width="0" height="0"></canvas>
    </div>
  </template>
  <script src="../helpers/round-rect.js"></script>
  <script src="./point.js"></script>
  <script src="./stitch.js"></script>
  <script src="./grid.js"></script>
  <script>
    'use strict';

    // TODO: Define objects to draw grid, ruler, pattern, etc. becasue it is hard to follow what is goin on in this file.

    class Canvas extends Polymer.Element {
      static get is() { return 'stitch-canvas'; }

      static get properties() {
        return {
          enabled: {
            type: Object,
            reflectToAttribute: true
          },

          zoom: {
            type: Number,
            reflectToAttribute: true,
            observer: '_zoomChanged'
          },

          pattern: {
            type: Object,
            reflectToAttribute: false,
            observer: "_patternChanged"
          }
        };
      }

      static get observers() {
        return [
          '_enabledChanged(enabled)',
          '_displayChanged(display.*)'
        ];
      }

      static toRelativeUnit(pt, ratio) {
        return {
          x: pt.x ? Math.floor(pt.x / ratio) : null,
          y: pt.y ? Math.floor(pt.y / ratio) : null
        }
      }
      
      static drawText(ctx, text, x, y, bg) {
        const symbolWidth = ctx.measureText(text).width,
          _x = Math.round(x - symbolWidth / 2);

        ctx.font = "12px Arial";

        if (bg) {
          ctx.strokeStyle = '#5f5f5f';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#dfdfdf';
          roundRect(ctx, _x - 5, y - 15, symbolWidth + 11, 20, 5, true, true);
        }
        ctx.fillStyle = '#000';
        ctx.fillText(text, _x, y);
      }

      constructor() {
        super();
      }

      connectedCallback() {
        super.connectedCallback();
        this.canvas = this.$.canvas;
        this.container = this.$.container;
        this.ctx = this.canvas.getContext('2d');
        this.grid = new Grid();
        this._debouncedDraw = this._draw.debounce(250);
        this._throttledDraw = this._draw.throttle(250);
      }

      get stitchSize() {
        return Math.round(this.zoom * 30);
      }

      reset() {
        this.stitches = new Array(this.dimension[0] * this.dimension[1]);
        this._draw();
      }

      _enabledChanged() {
        if (this.enabled) {
          this._init();
          this._draw();
        }
      }

      _zoomChanged() {
        if (this.enabled) {
          this._zoom({
            x: this.container.offsetWidth / 2,
            y: this.container.offsetHeight / 2
          });
        }
      }

      _zoom(focus) {
        let k = 1 - this.stitchSize / this.oldStitchSize;

        this._moveTo(
          Math.round((focus.x - this.offset.x) * k),
          Math.round((focus.y - this.offset.y) * k)
        );

        this.canvas.width = this.dimension[0] * this.stitchSize;
        this.canvas.height = this.dimension[1] * this.stitchSize;

        this._draw();
        this.oldStitchSize = this.stitchSize;
      }

      _displayChanged(e) {
        if (!this.enabled) return;
        this._draw(); 
      }

      _init() {
        this.dimension = [ this.pattern.width, this.pattern.height ];
        this.stitches = this.pattern.stitches;
        this.canvas.width = this.dimension[0] * this.stitchSize;
        this.canvas.height = this.dimension[1] * this.stitchSize;
        this.canvasLeft = this.canvas.offsetLeft,
        this.canvasTop = this.canvas.offsetTop,
        this.oldStitchSize = this.stitchSize;
        this.offset = new Point(0, 0);
        this.events = {
          mouseup: (e) => this._handleMouseUp(e),
          mousedown: (e) => this._handleMouseDown(e),
          mousemove: (e) => this._handleMouseMove(e),
          mousewheel: (e) => this._handleWheel(e)
        }

        // setup events
        for (let e in this.events) {
          this.canvas.addEventListener(e, this.events[e]);
        }

      }

      _draw(cached) {
        this._clearGrid();

        let 
          { ctx, offset, stitchSize: size, stitches } = this,

          begin = new Point(
            Math.max(0, offset.x % size - offset.x - size),
            Math.max(0, offset.y % size - offset.y - size)
          ),
          end = new Point(
            Math.min(this.container.offsetWidth - offset.x, this.canvas.width),
            Math.min(this.container.offsetHeight - offset.y, this.canvas.height)
          ),
          _begin = Canvas.toRelativeUnit(begin, size),
          _end = Canvas.toRelativeUnit(end, size);


        this._drawStitches(stitches, ctx, _begin, _end, size);
        
        this.display.grid && this.grid.draw(ctx, begin, end, size);

        this.display.ruler && this._drawRulers(this.ctx, offset, size);
      }

      _drawStitches(stitches, ctx, begin, end, size) {
        let args = [ctx, size, this.display.symbol, this.display.color];
        
        if (begin && end) {   
          for (let x = begin.x, stitch; x <= end.x; x++) {
            for (let y = begin.y; y <= end.y; y++) {
              stitch = stitches[x + this.dimension[0] * y];

              if (stitch) stitch.draw(...args);
            }
          }
        } else {
          stitches.forEach(s => s && s.draw(...args))
        }
      }

      _drawRulers(ctx, offset, size) {
        let x, y,
          begin = new Point(
            offset.x % (size * 10) - offset.x,
            offset.y % (size * 10) - offset.y
          ),
          end = new Point(
            -offset.x + this.canvas.width,
            -offset.y + this.canvas.height
          );

        // ctx.fillStyle = 'white';
        // ctx.fillRect(-offset.x, -offset.y, this.canvas.width, 30);

        for (x = begin.x; x <= end.x; x += size * 10) {
          Canvas.drawText(ctx, Canvas.toRelativeUnit(x, size), x, 20 - offset.y, true);
        }

        for (y = begin.y; y <= end.y; y += size * 10) {
          Canvas.drawText(ctx, Canvas.toRelativeUnit(y, size), 20 - offset.x, y + 5, true);
        }
      }

      _moveTo(x, y, cached) {
        this.container.scrollLeft -= x;
        this.container.scrollTop -= y;

        this.offset.set(-this.container.scrollLeft, -this.container.scrollTop);
        this._debouncedDraw();
      }

      _clearGrid() {
        let begin = new Point(0 - this.offset.x, 0 - this.offset.y),
          end = new Point(this.canvas.width, this.canvas.height);

        this.ctx.clearRect(begin.x, begin.y, end.x, end.y);
      }

      _setCell(pt, color) {
        if (this.mode === 'view') return;

        let i = pt.x + this.dimension[0] * pt.y;
        if (this.shape === 'eraser') {
          delete this.stitches[i];
          this._draw();
        } else if (!this.stitches[i] && this.shape !== 'eraser') {
          this.stitches[i] = new Stitch({
            x: pt.x,
            y: pt.y,
            symbol: this.stitch.symbol,
            color: this.stitch.color
          });
          this.stitches[i].draw(this.ctx, this.stitchSize);
        }
      }

      _getStitch(pt) {
        return this.stitches[ pt.x + this.dimension[0] * pt.y ];
      }

      _isInGrid(pt) {
        return pt.x >= 0 &&
          pt.x < this.dimension[0] &&
          pt.y >= 0 &&
          pt.y < this.dimension[1];
      }

      _handleSelect(e) {
        let 
          oldSelectedStitch,
          { ctx, stitchSize: size, offset, canvas } = this,
          pt = { 
            x: e.clientX - this.canvasLeft - offset.x, 
            y: e.clientY - this.canvasTop - offset.y 
          },
          selectedStitch = this._getStitch(Canvas.toRelativeUnit(pt, size));

        if (selectedStitch) {
          selectedStitch.toggle();
          this.grid.redraw();
        }
      }

      _handleMouseUp(e) {
        e.preventDefault();

        //this._handleSelect(e);

        this.moveStart = null;
        this.moveEnd = null;
      }

      _handleMouseDown(e) {
        e.preventDefault();
        this.moveStart = new Point( e.clientX, e.clientY );
        this.moveEnd = new Point( e.clientX, e.clientY );
      }

      _handleMouseMove(e) {
        console.log("move")
        e.preventDefault();

        if (this.moveStart) {
          let 
            deltaX = this.moveStart.x - this.moveEnd.x,
            deltaY = this.moveStart.y - this.moveEnd.y;

          if (deltaX || deltaY) this._moveTo(deltaX, deltaY, true);

          this.moveEnd.set( this.moveStart.x, this.moveStart.y );
          this.moveStart.set( e.clientX, e.clientY );  
        };
      }

      _handleWheel(e) {
        e.preventDefault();
        this._moveTo(-e.deltaX, -e.deltaY, true);
      }

      // _patternChanged() {
      //   this._enabledChanged();
      // }
    }

    customElements.define(Canvas.is, Canvas);
  </script>
</dom-module>
