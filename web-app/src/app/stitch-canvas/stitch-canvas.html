<dom-module id="stitch-canvas">
  <template>
    <style>
       :host {
        display: block;
        width: 100%;
        height: 700px;
        overflow: hidden;
      }
      #container {
        overflow: auto;
        height: 100%;
      }
      canvas {
        background: #f0f0f0;
        display: inline-block;
        box-sizing: content-box;
      }
    </style>
    <div id="container">
      <canvas id="canvas" width="0" height="0"></canvas>
    </div>
  </template>
  <script src="../helpers/debounce.js"></script>
  <script src="../helpers/round-rect.js"></script>
  <script src="./point.model.js"></script>
  <script src="./stitch.model.js"></script>
  <script>
    'use strict';

    // Consider better way to handle this functions. Not sure how good the idea is not have them in global scope.
    const
      toRelativeUnit = (n, ratio) => Math.floor(n / ratio),
      toPixel = (n, ratio) => n * ratio;

    // TODO: Define objects to draw grid, ruler, pattern, etc. becasue it is hard to follow what is goin on in this file.

    class Canvas extends Polymer.Element {
      static get is() { return 'stitch-canvas'; }

      static get properties() {
        return {
          enabled: {
            type: Object,
            reflectToAttribute: true
          },

          zoom: {
            type: Number,
            reflectToAttribute: true,
            observer: '_zoomChanged'
          },

          pattern: {
            type: Object,
            reflectToAttribute: false,
            observer: "_patternChanged"
          }
        };
      }

      static get observers() {
        return [
          '_enabledChanged(enabled)',
          '_displayChanged(display.*)'
        ];
      }

      static drawText(ctx, text, x, y, bg) {
        const symbolWidth = ctx.measureText(text).width,
          _x = Math.round(x - symbolWidth / 2);

        ctx.font = "12px Arial";

        if (bg) {
          ctx.strokeStyle = '#5f5f5f';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#dfdfdf';
          roundRect(ctx, _x - 5, y - 15, symbolWidth + 11, 20, 5, true, true);
        }
        ctx.fillStyle = '#000';
        ctx.fillText(text, _x, y);
      }

      constructor() {
        super();
      }

      connectedCallback() {
        super.connectedCallback();
        this.canvas = this.$.canvas;
        this.container = this.$.container;
        this._canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this._ctx = this._canvas.getContext('2d');
        this._debouncedDraw = debounce(this._draw.bind(this), 250);
      }

      get stitchSize() {
        return Math.round(this.zoom * 30);
      }

      reset() {
        this.cells = new Array(this.wCells * this.hCells);
        this._draw();
      }

      _enabledChanged() {
        if (this.enabled) {
          this._init();
          this._draw();
        }
      }

      _zoomChanged() {
        if (this.enabled) {
          this._zoom({
            x: this.container.offsetWidth / 2,
            y: this.container.offsetHeight / 2
          });
        }
      }

      _zoom(focus) {
        let k = 1 - this.stitchSize / this.oldStitchSize;

        this._moveTo(
          Math.round((focus.x - this.offset.x) * k),
          Math.round((focus.y - this.offset.y) * k)
        );

        this.canvas.width = this.wCells * this.stitchSize;
        this.canvas.height = this.hCells * this.stitchSize;
        this._draw();
        this.oldStitchSize = this.stitchSize;
      }

      _displayChanged(e) {
        if (!this.enabled) return;
        this._draw(); 
      }

      _init() {
        this.wCells = this.pattern ? this.pattern.width : 50;
        this.hCells = this.pattern ? this.pattern.height : 50;
        this.cells = this.pattern.cells;
        this.canvas.width = this.wCells * this.stitchSize;
        this.canvas.height = this.hCells * this.stitchSize;
        this.oldStitchSize = this.stitchSize;
        this.offset = new Point(0, 0);   // relative zero point - begin of ctx
        this.mode = 'view';
        this.events = {
          mouseup: (e) => this._handleMouseUp(e),
          mousedown: (e) => this._handleMouseDown(e),
          mousemove: (e) => this._handleMouseMove(e),
          mousewheel: (e) => this._handleWheel(e)

        }

        // setup events
        for (let e in this.events) {
          this.canvas.addEventListener(e, this.events[e]);
        }

      }

      _draw(cached) {
        this._clearGrid();

        let 
          offset = this.offset,
          size = this.stitchSize,

          begin = new Point(
            Math.max(0, offset.x % size - offset.x - size),
            Math.max(0, offset.y % size - offset.y - size)
          ),
          end = new Point(
            Math.min(this.container.offsetWidth - offset.x, this.canvas.width),
            Math.min(this.container.offsetHeight - offset.y, this.canvas.height)
          ),
          _begin = begin.toRelativeUnit(size),
          _end = end.toRelativeUnit(size);


        this._drawWorkspace(this.ctx, this.canvas.width, this.canvas.height);
        this._drawStitches(this.ctx, _begin, _end, size);
        
        this.display.grid && this._drawGrid(this.ctx, begin, end, size);

        this.display.ruler && this._drawRulers(this.ctx, offset, size);
      }

      _drawWorkspace(ctx, gridWidth, gridHeight) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, gridWidth, gridHeight);
      }

      _drawGrid(ctx, begin, end, size) {
        // TODO: Draw sharp lines when zoom is small.
        // TODO: Draw sharp lines on scroll. Consider to make scroll fixed or rounded or something.
        ctx.strokeStyle = 'lightgray';
        ctx.lineWidth = 1;
        ctx.beginPath();

        let x, y;
        for (x = begin.x + 0.5; x <= end.x + 1; x += size) {
          ctx.moveTo(x, begin.y);
          ctx.lineTo(x, end.y);
        }

        for (y = begin.y + 0.5; y <= end.y + 1; y += size) {
          ctx.moveTo(begin.x, y);
          ctx.lineTo(end.x, y);
        }

        ctx.stroke();

        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();

        for (let x = begin.x + 0.5; x <= end.x + 1; x += size) {
          if (x % (10 * size) === 0.5) {
            ctx.moveTo(x, begin.y);
            ctx.lineTo(x, end.y);
          }
        }

        for (let y = begin.y + 0.5; y <= end.y + 1; y += size) {
          if (y % (10 * size) === 0.5) {
            ctx.moveTo(begin.x, y);
            ctx.lineTo(end.x, y);
          }
        }

        ctx.stroke();
      }

      _drawStitches(ctx, begin, end, size) {
        for (let x = begin.x, cell; x <= end.x; x++) {
          for (let y = begin.y; y <= end.y; y++) {
            cell = this.cells[x + this.wCells * y];

            if (cell) cell.draw(ctx, size, this.display.symbol, this.display.color);
          }
        }
      }

      _drawRulers(ctx, offset, size) {
        let x, y,
          begin = new Point(
            offset.x % (size * 10) - offset.x,
            offset.y % (size * 10) - offset.y
          ),
          end = new Point(
            -offset.x + this.canvas.width,
            -offset.y + this.canvas.height
          );

        // ctx.fillStyle = 'white';
        // ctx.fillRect(-offset.x, -offset.y, this.canvas.width, 30);

        for (x = begin.x; x <= end.x; x += size * 10) {
          Canvas.drawText(ctx, toRelativeUnit(x, size), x, 20 - offset.y, true);
        }

        for (y = begin.y; y <= end.y; y += size * 10) {
          Canvas.drawText(ctx, toRelativeUnit(y, size), 20 - offset.x, y + 5, true);
        }
      }

      _moveTo(x, y, cached) {
        this.container.scrollLeft -= x;
        this.container.scrollTop -= y;

        this.offset.x = -this.container.scrollLeft;
        this.offset.y = -this.container.scrollTop;
        this._debouncedDraw();
      }

      _clearGrid() {
        let begin = new Point(0 - this.offset.x, 0 - this.offset.y),
          end = new Point(this.canvas.width, this.canvas.height);

        this.ctx.clearRect(begin.x, begin.y, end.x, end.y);
      }

      _setCell(pt, color) {
        if (this.mode === 'view') return;

        let i = pt.x + this.wCells * pt.y;
        if (this.shape === 'eraser') {
          delete this.cells[i];
          this._draw();
        } else if (!this.cells[i] && this.shape !== 'eraser') {
          this.cells[i] = new Stitch({
            x: pt.x,
            y: pt.y,
            symbol: this.stitch.symbol,
            color: this.stitch.color
          });
          this.cells[i].draw(this.ctx, this.stitchSize);
        }
      }

      _isInGrid(pt) {
        return pt.x >= 0 &&
          pt.x < this.wCells &&
          pt.y >= 0 &&
          pt.y < this.hCells;
      }

      _handleMouseUp(e) {
        e.preventDefault();

        this.moveStart = null;
        this.moveEnd = null;
      }

      _handleMouseDown(e) {
        e.preventDefault();
        this.moveStart = { x: e.clientX, y: e.clientY };
        this.moveEnd = { x: e.clientX, y: e.clientY };
      }

      _handleMouseMove(e) {
        e.preventDefault();

        if (this.moveStart) {
          let 
            deltaX = this.moveStart.x - this.moveEnd.x,
            deltaY = this.moveStart.y - this.moveEnd.y;

          if (deltaX || deltaY) this._moveTo(deltaX, deltaY, true);

          this.moveEnd = { x: this.moveStart.x, y: this.moveStart.y };
          this.moveStart = { x: e.clientX, y: e.clientY };  
        };
      }

      _handleWheel(e) {
        e.preventDefault();
        this._moveTo(-e.deltaX, -e.deltaY, true);
      }

      _patternChanged() {
        this._enabledChanged();
      }
    }

    customElements.define(Canvas.is, Canvas);
  </script>
</dom-module>