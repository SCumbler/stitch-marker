<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="stitch-canvas">
  <template>
    <style>
      :host {
        position: absolute;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        user-select: none;
      }
    </style>
    <canvas id="canvas"></canvas>
  </template>
  <script src="../helpers/round-rect.js"></script>
  <script src="./point.js"></script>
  <script src="./stitch.js"></script>
  <script src="./grid.js"></script>
  <script src="./tile.js"></script>
  <script src="./scene.js"></script>
  <script>
    class Canvas extends Polymer.Element {
      static get is() { return 'stitch-canvas'; }

      static get properties() {
        return {
          pattern: {
            type: Object,
            reflectToAttribute: false,
            observer: "patternChanged"
          }
        };
      }

      connectedCallback() {
        super.connectedCallback();

        // TODO: Remove event listers in disconnected callback.

        window.addEventListener('resize', event => this.renderScene());

        let reuestId = 0;
        let position = null;

        const getPosition = event => {
          const e = (event.touches && event.touches[0] || event);
          return new Point(e.clientX, e.clientY);
        }

        const onStart = event => {
          if ((event.type === "mouseenter" && event.buttons & 1 === 1) || event.type !== "mouseenter") {
            position = getPosition(event);
          }
        };

        const onEnd = event => position = null;

        const onMove = event => {
          if (position) {
            const newPosition = getPosition(event);
            const dx = newPosition.x - position.x;
            const dy = newPosition.y - position.y;
            position = newPosition;

            if (reuestId) cancelAnimationFrame(reuestId);
            reuestId = reuestId = requestAnimationFrame(() => this.scene.translate(dx, dy));
          }
        }

        ["mousedown", "mouseenter", "touchstart"].forEach(type => {
          this.$.canvas.addEventListener(type, onStart);
        });

        ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach(type => {
          this.$.canvas.addEventListener(type, onEnd);
        });

        ["mousemove", "touchmove"].forEach(type => {
          this.$.canvas.addEventListener(type, onMove);
        });
      }

      patternChanged(pattern) {
        const ctx = this.$.canvas.getContext('2d');
        this.scene = new Scene(ctx, pattern);
        this.renderScene();
      }

      renderScene() {
        this.$.canvas.width = this.offsetWidth;
        this.$.canvas.height = this.offsetHeight;
        this.scene.render();
      }
    }

    class A {
      constructor(a) {
        this.a = a;
      }
    }

    customElements.define(Canvas.is, Canvas);
  </script>
</dom-module>
