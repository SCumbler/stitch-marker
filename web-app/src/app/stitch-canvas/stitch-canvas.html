<dom-module id="stitch-canvas">
  <template>
    <style>
       :host {
        display: block;
        width: 100%;
        height: 700px;
        overflow: hidden;
      }

      canvas {
        background: #f0f0f0;
        display: inline-block;
        box-sizing: content-box;
      }
    </style>
    <canvas id="canvas" width="0" height="0"></canvas>
  </template>
  <script src="../helpers/debounce.js"></script>
  <script src="../helpers/round-rect.js"></script>
  <script src="./point.model.js"></script>
  <script src="./stitch.model.js"></script>
  <script>
    'use strict';
    const BACKGROUND_COLOR = 'white';
    const GRID_COLOR = 'lightgray';
    const LS_GRID_KEY = 'sm_grid';

    const toRelativeUnit = (n, ratio) => Math.floor(n / ratio),
          toPixel = (n, ratio) => n * ratio;

    class Canvas extends Polymer.Element {
      static get is() { return 'stitch-canvas'; }

      static get properties() {
        return {
          enabled: {
            type: Object,
            reflectToAttribute: true
          },

          zoom: {
            type: Number,
            reflectToAttribute: true
          }
        };
      }

      static get observers() {
        return [
          '_enabledChanged(enabled)',
          '_zoomChanged(zoom)',
          '_displayChanged(display.*)'
        ];
      }

      static drawText(ctx, text, x, y, bg) {
        const symbolWidth = ctx.measureText(text).width,
          _x = Math.round(x - symbolWidth / 2);
        
        ctx.font = "12px Arial";
        
        if (bg) {
          ctx.strokeStyle = '#5f5f5f';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#dfdfdf';
          roundRect(ctx, _x - 5, y - 15, symbolWidth + 11, 20, 5, true, true);
        }
        ctx.fillStyle = '#000';
        ctx.fillText(text, _x, y);
      }

      constructor() {
        super();

        let timer;
        window.addEventListener('resize', (e) => {
          // TODO: Discuss why this implementation is better than what was before. In my understanding canvas should fit into container it is rendered in.

          clearTimeout(timer);
          timer = setTimeout(() => {
            this._resize(window.innerWidth, window.innerHeight);
          }, 250);
        });
      }

      connectedCallback() {
        super.connectedCallback();
        this.canvas = this.$.canvas;
        this._canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this._ctx = this._canvas.getContext('2d');
        this._debouncedDrawCache = debounce(this._drawCache.bind(this), 250);
      }

      get stitchSize() {
        return Math.round(this.zoom * 5);
      }

      reset() {
        this.cells = new Array(this.wCells * this.hCells);
        this._draw();
      }

      toJSON() {
        return {
          cells: this.cells.filter(c => c)
        };
      }

      _enabledChanged() {
        if (this.enabled) {
          console.log('Rendering.');
          this._init();
          this._draw();
          this._drawCache();
        }
      }

      _zoomChanged(zoom) {
        if (this.enabled) {
          this._zoom({
            x: this.canvas.width / 2,
            y: this.canvas.height / 2
          }, zoom);
        }
      }

      _displayChanged(e) {
        if (!this.enabled) return;
        if (e.path === 'display.ruler') {
          this._draw(true);
        } else {
          this._draw();
          this._drawCache();
        }
      }

      _init() {
        this.zoom = this.zoom || 4;
        this.wCells = this.data ? this.data.width : 50;
        this.hCells = this.data ? this.data.height : 50;
        this.cells = this.data.cells;
        this.canvas.width =  this.offsetWidth;
        this.canvas.height = this.offsetHeight;
        this.oldStitchSize = this.stitchSize;
        this.offset = new Point(0, 0);   // relative zero point - begin of ctx
        this.mode = 'view';
        this.events = {
          mouseup: (e) => this._handleMouseUp(e),
          mousedown: (e) => this._handleMouseDown(e),
          mousemove: (e) => this._handleMouseMove(e),
          // touchstart : (e) => this._handleTouchStart(e),
          // touchend   : (e) => this.handleTouchEnd(e),
          // touchmove  : (e) => this.handleTouchMove(e),
          mousewheel: (e) => this._handleWheel(e)
          // wheel      : (e) => this._handleTouchStart(e),
          // scroll     : (e) => this._handleTouchStart(e),
        }

        // setup events
        for (let e in this.events) {
          this.canvas.addEventListener(e, this.events[e]);
        }

      }

      _drawCache() {
        let size = this.stitchSize,
          // draw grid only in window bounds
          gridWidth = toPixel(this.wCells, size),
          gridHeight = toPixel(this.hCells, size),
          begin = new Point(0, 0),
          end = new Point(gridWidth, gridHeight),
          _begin = begin.toRelativeUnit(size),
          _end = end.toRelativeUnit(size);

        this._canvas.width = gridWidth + 1;
        this._canvas.height = gridHeight + 1;
        this._drawWorkspace(this._ctx, gridWidth, gridHeight);
        this._drawStitches(this._ctx, _begin, _end, size);
        this.display.grid && this._drawGrid(this._ctx, begin, end, size);
      }

      _draw(cached) {
        this._clearGrid();

        let offset = this.offset,
          size = this.stitchSize,
          // draw grid only in window bounds
          gridWidth = toPixel(this.wCells, size),
          gridHeight = toPixel(this.hCells, size),
          begin = new Point(
            Math.max(0, offset.x % size - offset.x - size),
            Math.max(0, offset.y % size - offset.y - size)
          ),
          end = new Point(
            Math.min(this.canvas.width - offset.x, gridWidth),
            Math.min(this.canvas.height - offset.y, gridHeight)
          ),
          _begin = begin.toRelativeUnit(size),
          _end = end.toRelativeUnit(size);

        if (cached && this.zoom <= 6) {
          this._drawFromCache();
        } else {
          this._drawWorkspace(this.ctx, gridWidth, gridHeight);
          this._drawStitches(this.ctx, _begin, _end, size);
          this.display.grid && this._drawGrid(this.ctx, begin, end, size);
        }

        this.display.ruler && this._drawRulers(this.ctx, offset, size);
      }

      _drawFromCache() {
        this.ctx.drawImage(this._canvas, 0, 0, this._canvas.width, this._canvas.height);        
      }

      _drawWorkspace(ctx, gridWidth, gridHeight) {
        // background of grid
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, gridWidth, gridHeight);
      }

      _drawGrid(ctx, begin, end, size) {
        // color of grid
        ctx.strokeStyle = GRID_COLOR;
        ctx.lineWidth = 1;
        ctx.beginPath();

        let x, y;
        for (x = begin.x + 0.5; x <= end.x + 1; x += size) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, end.y);
        }

        for (y = begin.y + 0.5; y <= end.y + 1; y += size) {
          ctx.moveTo(0, y);
          ctx.lineTo(end.x, y);
        }
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let x = begin.x; x <= end.x + 1; x += size) {
          if (!(x % (10 * size))) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, end.y);
          }
        }

        for (let y = begin.y; y <= end.y + 1; y += size) {
          if (!(y % (10 * size))) {
            ctx.moveTo(0, y);
            ctx.lineTo(end.x, y);
          }
        }
        ctx.stroke();
      }

      _drawStitches(ctx, begin, end, size) {
        for (let x = begin.x, cell; x <= end.x; x++) {
          for (let y = begin.y; y <= end.y; y++) {
            cell = this.cells[x + this.wCells * y];

            if (cell) cell.draw(ctx, size, this.display.symbol, this.display.color);
          }
        }
      }

      _drawRulers(ctx, offset, size) {
        let x, y,
          begin = new Point(
            offset.x % (size * 10) - offset.x,
            offset.y % (size * 10) - offset.y
          ),
          end = new Point(
            -offset.x + this.canvas.width,
            -offset.y + this.canvas.height
          );

        // ctx.fillStyle = 'white';
        // ctx.fillRect(-offset.x, -offset.y, this.canvas.width, 30);

        for (x = begin.x; x <= end.x; x += size * 10) {
          Canvas.drawText(ctx, toRelativeUnit(x, size), x, 20 - offset.y, true);
        }

        for (y = begin.y; y <= end.y; y += size * 10) {
          Canvas.drawText(ctx, toRelativeUnit(y, size), 20 - offset.x, y + 5, true);
        }
      }

      _moveTo(x, y, cached) {
        this.offset.x += x;
        this.offset.y += y;
        this.ctx.translate(x, y);
        this._draw(cached);
        this.dispatchEvent(new CustomEvent('move', {detail: {offset: this.offset}}));
        // this._debouncedDrawCache();
      }

      _zoom(focus, zoom) {
        this.zoom = +zoom.toFixed(2);

        if (this.zoom >= 1) {
          let k = 1 - this.stitchSize / this.oldStitchSize;

          this._moveTo(
            Math.round((focus.x - this.offset.x) * k),
            Math.round((focus.y - this.offset.y) * k)
          );
          this.oldStitchSize = this.stitchSize;

          // caching after render
          this._debouncedDrawCache();
        }
      }

      _clearGrid() {
        let begin = new Point(0 - this.offset.x, 0 - this.offset.y),
          end = new Point(this.canvas.width, this.canvas.height);

        this.ctx.clearRect(begin.x, begin.y, end.x, end.y);
      }

      _resize(width, height) {
        this.ctx.translate(-this.offset.x, -this.offset.y);
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.translate(this.offset.x, this.offset.y);

        this._draw();
      }

      _setCell(pt, color) {
        if (this.mode === 'view') return;

        let i = pt.x + this.wCells * pt.y;
        if (this.shape === 'eraser') {
          delete this.cells[i];
          this._draw();
        } else if (!this.cells[i] && this.shape !== 'eraser') {
          this.cells[i] = new Stitch({
            x: pt.x,
            y: pt.y,
            symbol: this.stitch.symbol,
            color: this.stitch.color
          });
          this.cells[i].draw(this.ctx, this.stitchSize);
        }
      }

      _isInGrid(pt) {
        return pt.x >= 0 &&
          pt.x < this.wCells &&
          pt.y >= 0 &&
          pt.y < this.hCells;
      }

      // events handlers

      _handleMouseUp(e) {
        e.preventDefault();
        // if (this.mode === 'draw') {
        //   let pt = new Point(
        //     e.clientX - this.offset.x,
        //     e.clientY - this.offset.y
        //   ).toRelativeUnit(this.stitchSize);

        //   if (this.inGrid(pt)) {
        //       this.setCell(pt, $colorpicker && $colorpicker.value || 'black');
        //   }
        // }
        let pt = new Point(
          e.clientX - this.offset.x,
          e.clientY - this.offset.y
        ).toRelativeUnit(this.stitchSize);

        if (this.mode === 'edit' && this._isInGrid(pt)) {
          this._setCell(pt, this.color);
        }

        this.moveStart = null;
      }

      _handleMouseDown(e) {
        e.preventDefault();
        this.moveStart = { x: e.clientX, y: e.clientY };

        let moveEnd = { x: e.clientX, y: e.clientY },
          move = () => {
            if (this.moveStart) {
              let deltaX = this.moveStart.x - moveEnd.x,
                deltaY = this.moveStart.y - moveEnd.y;

              if (deltaX || deltaY) this._moveTo(deltaX, deltaY, true);

              moveEnd = { x: this.moveStart.x, y: this.moveStart.y };
              requestAnimationFrame(move);
            }
          }
        move();
      }

      _handleMouseMove(e) {
        e.preventDefault();
        if (e.which === 1 && this.moveStart) {
          let pt = new Point(
            e.clientX - this.offset.x,
            e.clientY - this.offset.y
          ).toRelativeUnit(this.stitchSize);

          if (this.mode === 'edit' && this._isInGrid(pt)) {
            this._setCell(pt, this.color);
            this._debouncedDrawCache();
          } else {
            this.moveStart = { x: e.clientX, y: e.clientY };
          }
        } else {
          // this.moveStart = null;
        }
      }
      _handleWheel(e) {
        e.preventDefault();

        this._moveTo(-e.deltaX, -e.deltaY, true);

        // this.moveStart = { x: e.clientX, y: e.clientY };
      }
      _handleTouchMove(e) { }
      _handleTouchEnd(e) {
        this.moveStart = null;
      }
      
    }

    customElements.define(Canvas.is, Canvas);
  </script>
</dom-module>